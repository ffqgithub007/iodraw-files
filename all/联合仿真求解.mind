{"root":{"data":{"id":"d7q9vp7swfc0","created":1739343692072,"text":"联合仿真求解","expandState":"expand"},"children":[{"data":{"id":"d7q9vvswgyo0","created":1739343706409,"text":"关键词："},"children":[{"data":{"id":"d7q9w2c19iw0","created":1739343720626,"text":"关键词：联合仿真系统；嵌套代数环；Kosaraju 算法；Newton-NPHSS 迭代法"},"children":[]}]},{"data":{"id":"d7r3gcbiym80","created":1739427121835,"text":"### Java 实现检测有向图中的所有嵌套环路\n\n\n为了在有向图中找到所有的嵌套环路，可以采用深度优先搜索（DFS）算法来遍历图形结构并记录访问路径。当遇到已经访问过的节点时，则表明存在一个环路。\n\n\n下面是一个基于 DFS 的解决方案：\n\n\n```java\nimport java.util.*;\n\n\npublic class CycleDetection {\n\n\n\tprivate static final int WHITE = 0; // Node not visited yet.\n\tprivate static final int GRAY = 1;  // Node being processed (recursion stack).\n\tprivate static final int BLACK = 2; // Node fully processed.\n\n\n\tpublic List<List<Integer>> findAllNestedCycles(List<List<Integer>> adjList) {\n\t    Map<Integer, Integer> colorMap = new HashMap<>();\n\t    Stack<Integer> pathStack = new Stack<>();\n\t    Set<Set<Integer>> allCycles = new HashSet<>();\n\n\n\t    for (int i = 0; i < adjList.size(); ++i) {\n\t        if (!colorMap.containsKey(i)) {\n\t            dfs(adjList, i, colorMap, pathStack, allCycles);\n\t        }\n\t    }\n\n\n\t    return new ArrayList<>(allCycles.stream().map(ArrayList::new).toList());\n\t}\n\n\n\tprivate void dfs(List<List<Integer>> adjList,\n\t                 int currentNode,\n\t                 Map<Integer, Integer> colorMap,\n\t                 Stack<Integer> pathStack,\n\t                 Set<Set<Integer>> allCycles) {\n\t\t\n\t    colorMap.put(currentNode, GRAY); // Mark current node as processing.\n\t    pathStack.push(currentNode);\n\n\n\t    for (Integer neighbor : adjList.get(currentNode)) {            \n\t        if (colorMap.getOrDefault(neighbor, WHITE) == GRAY) {\n\t            // Found a back edge indicating a cycle.\n\t            Set<Integer> cycleNodes = extractCycle(pathStack, neighbor);\n\t            allCycles.add(cycleNodes);\n\t        \t\n\t        } else if (colorMap.getOrDefault(neighbor, WHITE) == WHITE) {\n\t            dfs(adjList, neighbor, colorMap, pathStack, allCycles);\n\t        }\n\t    }\n\n\n\t    colorMap.put(currentNode, BLACK); // Fully processed this node.\n\t    pathStack.pop();\n\t}\n\n\n\tprivate Set<Integer> extractCycle(Stack<Integer> pathStack, int startNode) {\n\t    Deque<Integer> tempDeque = new ArrayDeque<>(pathStack);\n\t    Set<Integer> cycleNodes = new LinkedHashSet<>();\n\t    while (!tempDeque.isEmpty()) {\n\t        int topElement = tempDeque.pollLast();\n\t        cycleNodes.add(topElement);\n\t        if (topElement == startNode) break;\n\t    }\n\t    return cycleNodes;\n\t}\n}\n```\n\n\n此代码片段定义了一个 `findAllNestedCycles` 方法用于查找给定邻接表表示的有向图中存在的所有循环，并返回这些循环作为整数列表集合的形式。","layout_mind_offset":{"x":-339,"y":1989.0000464022157}},"children":[]},{"data":{"id":"d7ve5m78ivc0","created":1739863553372,"text":"package com.ps.muh.schedule.utils;\n\n/**\n * @author fangfeiqiang\n * @version 1.0.0\n * @title GraphSearch\n * @description TODO\n * @date 2025/2/14 11:44\n */\nimport org.springframework.util.CollectionUtils;\n\nimport java.util.*;\n\nclass ProcessGraphCycle {\n\tprivate int V; // 顶点数量\n\tprivate List<List<Integer>> adj; // 邻接表\n\tpublic List<List<Integer>> cycles = new ArrayList<>(); // 存储所有环\n\n\tpublic ProcessGraphCycle(int v) {\n\t    V = v;\n\t    adj = new ArrayList<>(v);\n\t    for (int i = 0; i < v; ++i)\n\t        adj.add(new LinkedList<>());\n\t}\n\n\tpublic void addEdge(int v, int w) {\n\t    adj.get(v).add(w);\n\t}\n\tpublic void deleteEdge(int v, int w) {\n\t    adj.get(v).remove(Integer.valueOf(w));\n\t}\n\n\t// Tarjan's 算法找强连通分量\n\tvoid findSCCs() {\n\t    int[] index = new int[V];\n\t    int[] lowlink = new int[V];\n\t    boolean[] onStack = new boolean[V];\n\t    Stack<Integer> stack = new Stack<>();\n\t    int indexCounter = 0;\n\t    List<List<Integer>> sccs = new ArrayList<>();\n\n\t    for (int i = 0; i < V; i++) {\n\t        if (index[i] == 0) {\n\t            tarjanSCC(i, index, lowlink, onStack, stack, indexCounter, sccs);\n\t        }\n\t    }\n\n\t    // 打印强连通分量\n\t    for (List<Integer> scc : sccs) {\n\t        System.out.println(\"SCC: \" + scc);\n\t        findCyclesInSCC(scc);\n\t    }\n\t}\n\n\tprivate void tarjanSCC(int v, int[] index, int[] lowlink, boolean[] onStack, Stack<Integer> stack, int indexCounter, List<List<Integer>> sccs) {\n\t    index[v] = indexCounter++;\n\t    lowlink[v] = index[v];\n\t    stack.push(v);\n\t    onStack[v] = true;\n\n\t    for (int w : adj.get(v)) {\n\t        if (index[w] == 0) {\n\t            tarjanSCC(w, index, lowlink, onStack, stack, indexCounter, sccs);\n\t            lowlink[v] = Math.min(lowlink[v], lowlink[w]);\n\t        } else if (onStack[w]) {\n\t            lowlink[v] = Math.min(lowlink[v], index[w]);\n\t        }\n\t    }\n\n\t    if (lowlink[v] == index[v]) {\n\t        System.out.println(\"强连通分量的顶端节点：\"+v);\n\t        List<Integer> scc = new ArrayList<>();\n\t        while (true) {\n\t            int w = stack.pop();\n\t            onStack[w] = false;\n\t            scc.add(w);\n\t            if (w == v) break;\n\t        }\n\t        sccs.add(scc);\n\t    }\n\t}\n\n/*    // 在强连通分量中查找环\n\tprivate void findCyclesInSCC(List<Integer> scc) {\n\t    boolean[] visited = new boolean[V];\n\t    for (int start : scc) {\n//            System.out.println(\"start: \" + start);\n\t        if (!visited[start]) {\n\t            List<Integer> cycle = new ArrayList<>();\n\t            dfsFindCycle(start, visited, cycle, new HashSet<>());\n\t            if (cycle.size() > 0) {\n\t                System.out.println(\"Cycle found: \" + cycle);\n\t            }\n\t        }\n\t    }\n\t}*/\n\n\t// 在强连通分量中查找环\n\tprivate void findCyclesInSCC(List<Integer> scc) {\n\t    if(scc.size()>1){\n\t        System.out.println(\"Cycle found: \" + scc);\n\t        cycles.add(scc);\n\t    }else{\n//            int node = scc.get(0);\n//            List<Integer> edges = adj.get(node);\n//            if (edges != null && edges.contains(node)) {\n//                System.out.println(\"Cycle found: \" + scc);\n//            }\n\t    }\n\n//        boolean[] visited = new boolean[V];\n//        for (int start : scc) {\n//            if (!visited[start]) {\n//                List<Integer> cycle = new ArrayList<>();\n//                dfsFindCycle(start, visited, cycle, new HashSet<>());\n//                if (cycle.size() > 0) {\n//                    System.out.println(\"Cycle found: \" + cycle);\n//                }\n//            }\n//        }\n\t}\n\n\tprivate boolean dfsFindCycle(int v, boolean[] visited, List<Integer> cycle, Set<Integer> recStack) {\n\t    if (recStack.contains(v)) {\n\t        cycle.add(v);\n\t        return true;\n\t    }\n\t    if (visited[v]) return false;\n\n\t    visited[v] = true;\n\t    recStack.add(v);\n\t    for (int neighbor : adj.get(v)) {\n\t        if (dfsFindCycle(neighbor, visited, cycle, recStack)) {\n\t            cycle.add(v);\n\t            return true;\n\t        }\n\t    }\n\t    recStack.remove(v);\n\t    return false;\n\t}\n\n\t// 拓扑方法\n\tpublic boolean isCyclicUtil(int v, boolean[] visited, boolean[] recStack) {\n\t    if (recStack[v]) {\n\t        return true;\n\t    }\n\t    if (visited[v]) {\n\t        return false;\n\t    }\n\n\t    visited[v] = true;\n\t    recStack[v] = true;\n\n\t    for (int i : adj.get(v)) {\n\t        if (isCyclicUtil(i, visited, recStack)) {\n\t            return true;\n\t        }\n\t    }\n\n\t    recStack[v] = false;\n\t    return false;\n\t}\n\n\tpublic boolean isCyclic() {\n\t    boolean[] visited = new boolean[V];\n\t    boolean[] recStack = new boolean[V];\n\n\t    for (int i = 0; i < V; i++) {\n\t        if (isCyclicUtil(i, visited, recStack)) {\n\t            return true;\n\t        }\n\t    }\n\n\t    return false;\n\t}\n\n\tpublic void topologicalSort() {\n\t    if (isCyclic()) {\n\t        System.out.println(\"图中存在环，无法进行拓扑排序\");\n\t        return;\n\t    }\n\n\t    boolean[] visited = new boolean[V];\n\t    Stack<Integer> stack = new Stack<>();\n\n\t    for (int i = 0; i < V; i++) {\n\t        if (!visited[i]) {\n\t            topologicalSortUtil(i, visited, stack);\n\t        }\n\t    }\n\n\t    while (!stack.isEmpty()) {\n\t        System.out.print(stack.pop() + \" \");\n\t    }\n\t}\n\n\tprivate void topologicalSortUtil(int v, boolean[] visited, Stack<Integer> stack) {\n\t    visited[v] = true;\n\n\t    for (int i : adj.get(v)) {\n\t        if (!visited[i]) {\n\t            topologicalSortUtil(i, visited, stack);\n\t        }\n\t    }\n\n\t    stack.push(v);\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t    ProcessGraphCycle g = new ProcessGraphCycle(10);\n\t   /* g.addEdge(0, 1);\n\t    g.addEdge(1, 2);\n\t    g.addEdge(2, 0);\n\t    g.addEdge(2, 3);\n\t    g.addEdge(3, 4);\n\t    g.addEdge(4, 5);\n\t    g.addEdge(5, 3);*/\n\n\t    /**\n\t     * 案例一\n\t     */\n\t    g.addEdge(0, 1);\n\t    g.addEdge(1, 2);\n\t    g.addEdge(2, 0);\n\t    g.addEdge(0, 3);\n\t    g.addEdge(3, 4);\n\t    g.addEdge(4, 5);\n\t    g.addEdge(4, 6);\n\t    g.addEdge(6, 5);\n\t    g.addEdge(5, 3);  // 创建循环 3-4-5-3\n\t    g.addEdge(6, 7);\n\t    g.addEdge(7, 8);\n\t    g.addEdge(8, 7); // 创建循环 7-8\n\t    g.addEdge(9,1);\n\n\t    /**\n\t     * 案例二\n\t     */\n\t   /* g.addEdge(0, 1);\n\t    g.addEdge(0, 2);\n\t    g.addEdge(2, 3);\n\t    g.addEdge(4, 5);\n\t    g.addEdge(5, 6);\n\t    g.addEdge(6, 3);\n*/\n\n\t    /**\n\t     * 案例三\n\t     */\n\n\t   /* g.addEdge(0, 1);\n\t    g.addEdge(1, 2);\n\t    g.addEdge(2, 3);\n\t    g.addEdge(3, 4);\n\t    g.addEdge(4, 5);\n\t    g.addEdge(5, 6);\n\t    g.addEdge(2, 1);\n\t    g.addEdge(4,2);\n\t    g.addEdge(4, 1);\n\t    g.addEdge(6,5);\n\t    g.addEdge(6,1);*/\n\t    g.findSCCs();\n\n\t /*   System.out.println(\"是否存在环：\" + g.cycles);\n\t    if (!CollectionUtils.isEmpty(g.cycles)) {\n\t        for( int i = 0; i < g.cycles.size(); i++) {\n\t            System.out.println(\"SCC \" + i + \" : \" + g.cycles.get(i));\n\t            List<Integer> cycle = g.cycles.get(i);\n\t            g.deleteEdge(cycle.get(0),cycle.get(cycle.size()-1));\n\t        }\n\t    }*/\n\n\t    CycleDetection cycleDetection = new CycleDetection();\n\t    List<List<Integer>>  result = cycleDetection.findAllNestedCycles(g.adj);\n\t    System.out.println(\"所有的环：\" + result);\n\t    if (!CollectionUtils.isEmpty(result)) {\n\t        for( int i = 0; i < result.size(); i++) {\n\t            System.out.println(\"SCC \" + i + \" : \" +result.get(i));\n\t            List<Integer> cycle = result.get(i);\n\t            g.deleteEdge(cycle.get(0),cycle.get(cycle.size()-1));\n\t        }\n\t    }\n\n\n\n\n\t    System.out.println(\"拓扑排序结果：\");\n\t    g.topologicalSort();\n\t}\n}"},"children":[]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}