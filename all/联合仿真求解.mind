{"root":{"data":{"id":"d7q9vp7swfc0","created":1739343692072,"text":"联合仿真求解"},"children":[{"data":{"id":"d7q9vvswgyo0","created":1739343706409,"text":"关键词："},"children":[{"data":{"id":"d7q9w2c19iw0","created":1739343720626,"text":"关键词：联合仿真系统；嵌套代数环；Kosaraju 算法；Newton-NPHSS 迭代法"},"children":[]}]},{"data":{"id":"d7r3gcbiym80","created":1739427121835,"text":"### Java 实现检测有向图中的所有嵌套环路\n\n\n为了在有向图中找到所有的嵌套环路，可以采用深度优先搜索（DFS）算法来遍历图形结构并记录访问路径。当遇到已经访问过的节点时，则表明存在一个环路。\n\n\n下面是一个基于 DFS 的解决方案：\n\n\n```java\nimport java.util.*;\n\n\npublic class CycleDetection {\n\n\n\tprivate static final int WHITE = 0; // Node not visited yet.\n\tprivate static final int GRAY = 1;  // Node being processed (recursion stack).\n\tprivate static final int BLACK = 2; // Node fully processed.\n\n\n\tpublic List<List<Integer>> findAllNestedCycles(List<List<Integer>> adjList) {\n\t    Map<Integer, Integer> colorMap = new HashMap<>();\n\t    Stack<Integer> pathStack = new Stack<>();\n\t    Set<Set<Integer>> allCycles = new HashSet<>();\n\n\n\t    for (int i = 0; i < adjList.size(); ++i) {\n\t        if (!colorMap.containsKey(i)) {\n\t            dfs(adjList, i, colorMap, pathStack, allCycles);\n\t        }\n\t    }\n\n\n\t    return new ArrayList<>(allCycles.stream().map(ArrayList::new).toList());\n\t}\n\n\n\tprivate void dfs(List<List<Integer>> adjList,\n\t                 int currentNode,\n\t                 Map<Integer, Integer> colorMap,\n\t                 Stack<Integer> pathStack,\n\t                 Set<Set<Integer>> allCycles) {\n\t\t\n\t    colorMap.put(currentNode, GRAY); // Mark current node as processing.\n\t    pathStack.push(currentNode);\n\n\n\t    for (Integer neighbor : adjList.get(currentNode)) {            \n\t        if (colorMap.getOrDefault(neighbor, WHITE) == GRAY) {\n\t            // Found a back edge indicating a cycle.\n\t            Set<Integer> cycleNodes = extractCycle(pathStack, neighbor);\n\t            allCycles.add(cycleNodes);\n\t        \t\n\t        } else if (colorMap.getOrDefault(neighbor, WHITE) == WHITE) {\n\t            dfs(adjList, neighbor, colorMap, pathStack, allCycles);\n\t        }\n\t    }\n\n\n\t    colorMap.put(currentNode, BLACK); // Fully processed this node.\n\t    pathStack.pop();\n\t}\n\n\n\tprivate Set<Integer> extractCycle(Stack<Integer> pathStack, int startNode) {\n\t    Deque<Integer> tempDeque = new ArrayDeque<>(pathStack);\n\t    Set<Integer> cycleNodes = new LinkedHashSet<>();\n\t    while (!tempDeque.isEmpty()) {\n\t        int topElement = tempDeque.pollLast();\n\t        cycleNodes.add(topElement);\n\t        if (topElement == startNode) break;\n\t    }\n\t    return cycleNodes;\n\t}\n}\n```\n\n\n此代码片段定义了一个 `findAllNestedCycles` 方法用于查找给定邻接表表示的有向图中存在的所有循环，并返回这些循环作为整数列表集合的形式。","layout_mind_offset":{"x":-854,"y":90}},"children":[]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}